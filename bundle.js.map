{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///ts_src/Patch/Native.ts","webpack:///ts_src/Utilities.ts","webpack:///ts_src/CustomElementInternals.ts","webpack:///ts_src/custom-elements.ts","webpack:///ts_src/Deferred.ts","webpack:///ts_src/DocumentConstructionObserver.ts","webpack:///ts_src/CustomElementRegistry.ts","webpack:///ts_src/Patch/Interface/ParentNode.ts","webpack:///ts_src/Patch/Element.ts","webpack:///ts_src/CustomElementState.ts","webpack:///ts_src/Patch/Interface/ChildNode.ts","webpack:///ts_src/AlreadyConstructedMarker.ts","webpack:///ts_src/Patch/HTMLElement.ts","webpack:///ts_src/Patch/Document.ts","webpack:///ts_src/Patch/DocumentFragment.ts","webpack:///ts_src/Patch/Node.ts","webpack:///./src/highlighter.js","webpack:///./src/menu.js","webpack:///./src/range.js","webpack:///./src/listeners.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Document_createElement","window","Document_createElementNS","Document_importNode","Document_prepend","Document_append","DocumentFragment_prepend","DocumentFragment_append","Node_cloneNode","Node_appendChild","Node_insertBefore","Node_removeChild","Node_replaceChild","Node_textContent","getOwnPropertyDescriptor","Element_attachShadow","Element_innerHTML","Element_getAttribute","Element_setAttribute","Element_removeAttribute","Element_getAttributeNS","Element_setAttributeNS","Element_removeAttributeNS","Element_insertAdjacentElement","Element_insertAdjacentHTML","Element_prepend","Element_append","Element_before","Element_after","Element_replaceWith","Element_remove","HTMLElement","HTMLElement_innerHTML","HTMLElement_insertAdjacentElement","HTMLElement_insertAdjacentHTML","reservedElementNameSet","Set","isValidCustomElementName","reserved","validForm","test","nativeContains","document","isConnected","nativeValue","node","undefined","current","childrenFromFragment","nativeChildren","fragment","Array","children","Node","nextSiblingOrAncestorSibling","CustomElementInternals","noDocumentConstructionObserver","priorCustomElements","shadyDomFastWalk","this","forEachElement","sd","callback","querySelectorAll","elements","walkDeepDescendantElements","root","element","localName","importNode","visitedImports","child","f","shadowRoot","firstChild","patchTree","patchElement","__CE_patched","connectTree","upgradeReaction","disconnectTree","patchAndUpgradeTree","options","upgrade","gatherElements","import","__CE_documentLoadHandled","clonedVisitedImports","ownerDocument","registry","doc","internal_localNameToDefinition","definition","constructionStack","result","constructorFunction","Error","__CE_state","e","__CE_definition","observedAttributes","getAttribute","_upgradeAnElement","attributeChangedCallback","connectedCallback","reportTheException","NS_HTML","HTMLUnknownElement","message","error","filename","lineno","colno","event","ErrorEvent","cancelable","event.preventDefault","configurable","console","Deferred","constructor","Promise","DocumentConstructionObserver","internals","MutationObserver","childList","subtree","disconnect","CustomElementRegistry","Map","this._flushCallback","internal_assertCanDefineLocalName","SyntaxError","internal_reifyDefinition","TypeError","getCallback","callbackValue","disconnectedCallback","adoptedCallback","elementsWithStableDefinitions","unflushedLocalNames","elementsWithPendingDefinitions","pendingElements","_localNameToDefinition","pendingUpgradableElements","deferred","existingDefinition","constructorGetter","appendPrependPatch","flattenedNodes","connectedElements","builtInMethod","builtIn","destination","patch_innerHTML","baseDescriptor","set","removedElements","custom","patch_insertAdjacentElement","destination.insertAdjacentElement","wasConnected","insertedElement","baseMethod","patch_insertAdjacentHTML","upgradeNodesInRange","nodes","destination.insertAdjacentHTML","strPosition","position","marker","previousSibling","parentNode","lastChild","String","nextSibling","Element","Element.prototype.attachShadow","_patchesNode","addElementPatch","isTemplate","content","rawElement","assignedValue","container","Element.prototype.setAttribute","oldValue","newValue","Element.prototype.setAttributeNS","Element.prototype.removeAttribute","Element.prototype.removeAttributeNS","PatchParentNode","prepend","append","beforeAfterPatch","destination.replaceWith","apply","destination.remove","PatchChildNode","resolve","readyState","mutations","addedNodes","j","define","whenDefined","prior","_promise","anyDefinitionExists","definitionHasFlushed","polyfillWrapFlushCallback","inner","alreadyConstructedMarker","installPolyfill","PatchedHTMLElement","_constructorToDefinition","lastIndex","setPrototypeOf","writable","PatchHTMLElement","Document","Document.prototype.createElement","createAnElement","Document.prototype.importNode","clone","Document.prototype.createElementNS","PatchDocument","DocumentFragment","PatchNode","patch_textContent","removedNodes","childNodes","childNodesLength","Node.prototype.insertBefore","insertedNodes","nativeResult","nodeWasConnectedElement","Node.prototype.appendChild","Node.prototype.cloneNode","Node.prototype.removeChild","Node.prototype.replaceChild","nodeToInsert","nodeToInsertWasConnectedElement","thisIsConnected","addNodePatch","parts","PatchElement","customElements","Highlight","highlightColor","super","style","backgroundColor","createHighlight","color","hlRanges","range","getSelection","getRangeAt","commonAncestorContainer","nodeType","parentElement","selectionRanges","walker","createTreeWalker","NodeFilter","SHOW_TEXT","acceptNode","currentRange","data","match","intersectsNode","textInSelection","FILTER_ACCEPT","FILTER_REJECT","nextNode","curNode","currentNode","curRange","Range","selectNode","startContainer","endContainer","setStart","startOffset","setEnd","endOffset","push","getRanges","HighlightSnippet","surroundContents","showHighlightMenu","isBackwards","highlightMenu","createElement","classList","add","pointer","colors","colorOptions","optionWrapper","option","setAttribute","onclick","target","dataset","generateColorOptions","forEach","body","tempPositionMarker","textContent","rangeCopy","cloneRange","collapse","insertNode","markerCoords","getBoundingClientRect","log","left","offsetWidth","pageXOffset","top","offsetHeight","pageYOffset","vertOffset","endParent","lineHeight","getComputedStyle","getPropertyValue","lastParentFontSize","parseFloat","getLastParentLineHeight","remove","currentMenu","elemToNormalize","onmouseup","selection","rangeCount","isCollapsed","backwards","testRange","anchorNode","anchorOffset","focusNode","focusOffset","collapsed","onmousedown","contains","normalize","removeAllRanges"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nexport const Document_createElement = window.Document.prototype.createElement;\nexport const Document_createElementNS =\n    window.Document.prototype.createElementNS;\nexport const Document_importNode = window.Document.prototype.importNode;\n\nexport const Document_prepend = window.Document.prototype['prepend'];\nexport const Document_append = window.Document.prototype['append'];\nexport const DocumentFragment_prepend =\n    window.DocumentFragment.prototype['prepend'];\nexport const DocumentFragment_append =\n    window.DocumentFragment.prototype['append'];\nexport const Node_cloneNode = window.Node.prototype.cloneNode;\nexport const Node_appendChild = window.Node.prototype.appendChild;\nexport const Node_insertBefore = window.Node.prototype.insertBefore;\nexport const Node_removeChild = window.Node.prototype.removeChild;\nexport const Node_replaceChild = window.Node.prototype.replaceChild;\nexport const Node_textContent =\n    Object.getOwnPropertyDescriptor(window.Node.prototype, 'textContent');\nexport const Element_attachShadow = window.Element.prototype['attachShadow'];\nexport const Element_innerHTML =\n    Object.getOwnPropertyDescriptor(window.Element.prototype, 'innerHTML');\nexport const Element_getAttribute = window.Element.prototype.getAttribute;\nexport const Element_setAttribute = window.Element.prototype.setAttribute;\nexport const Element_removeAttribute = window.Element.prototype.removeAttribute;\nexport const Element_getAttributeNS = window.Element.prototype.getAttributeNS;\nexport const Element_setAttributeNS = window.Element.prototype.setAttributeNS;\nexport const Element_removeAttributeNS =\n    window.Element.prototype.removeAttributeNS;\nexport const Element_insertAdjacentElement =\n    window.Element.prototype['insertAdjacentElement'];\nexport const Element_insertAdjacentHTML =\n    window.Element.prototype['insertAdjacentHTML'];\nexport const Element_prepend = window.Element.prototype['prepend'];\nexport const Element_append = window.Element.prototype['append'];\nexport const Element_before = window.Element.prototype['before'];\nexport const Element_after = window.Element.prototype['after'];\nexport const Element_replaceWith = window.Element.prototype['replaceWith'];\nexport const Element_remove = window.Element.prototype['remove'];\nexport const HTMLElement = window.HTMLElement;\nexport const HTMLElement_innerHTML =\n    Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, 'innerHTML');\nexport const HTMLElement_insertAdjacentElement =\n    window.HTMLElement.prototype['insertAdjacentElement'];\nexport const HTMLElement_insertAdjacentHTML =\n    window.HTMLElement.prototype['insertAdjacentHTML'];\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport {HTMLImportElement} from './Externs.js';\n\nconst reservedElementNameSet = new Set<string>();\n// IE11 does not support constructing a set using an iterable.\n['annotation-xml',\n 'color-profile',\n 'font-face',\n 'font-face-src',\n 'font-face-uri',\n 'font-face-format',\n 'font-face-name',\n 'missing-glyph',\n].forEach(item => reservedElementNameSet.add(item));\n\nexport function isValidCustomElementName(localName: string) {\n  const reserved = reservedElementNameSet.has(localName);\n  const validForm = /^[a-z][.0-9_a-z]*-[-.0-9_a-z]*$/.test(localName);\n  return !reserved && validForm;\n}\n\n// Note, IE11 doesn't have `document.contains`.\nconst nativeContains = document.contains ?\n    document.contains.bind(document) :\n    document.documentElement.contains.bind(document.documentElement);\n\nexport function isConnected(node: Node) {\n  // Use `Node#isConnected`, if defined.\n  const nativeValue = node.isConnected;\n  if (nativeValue !== undefined) {\n    return nativeValue;\n  }\n  // Optimization: It's significantly faster here to try to use `contains`,\n  // especially on Edge/IE/\n  if (nativeContains(node)) {\n    return true;\n  }\n\n  let current: Node|undefined = node;\n  while (current &&\n         !(current.__CE_isImportDocument || current instanceof Document)) {\n    current = current.parentNode ||\n        (window.ShadowRoot && current instanceof ShadowRoot ? current.host :\n                                                              undefined);\n  }\n  return !!(\n      current &&\n      (current.__CE_isImportDocument || current instanceof Document));\n}\n\nexport function childrenFromFragment(fragment: DocumentFragment): Array<Element> {\n  // Note, IE doesn't have `children` on document fragments.\n  const nativeChildren = fragment.children;\n  if (nativeChildren) {\n    return Array.prototype.slice.call(nativeChildren);\n  }\n  const children: Array<Element> = [];\n  for (let n = fragment.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType === Node.ELEMENT_NODE) {\n      children.push(n as Element);\n    }\n  }\n  return children;\n}\n\nfunction nextSiblingOrAncestorSibling(root: Node, start: Node) {\n  let node: Node|null = start;\n  while (node && node !== root && !node.nextSibling) {\n    node = node.parentNode;\n  }\n  return (!node || node === root) ? null : node.nextSibling;\n}\n\n\nfunction nextNode(root: Node, start: Node) {\n  return start.firstChild ? start.firstChild :\n                            nextSiblingOrAncestorSibling(root, start);\n}\n\nexport function walkDeepDescendantElements(\n    root: Node, callback: (elem: Element) => void, visitedImports?: Set<Node>) {\n  let node: Node|null = root;\n  while (node) {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n\n      callback(element);\n\n      const localName = element.localName;\n      if (localName === 'link' && element.getAttribute('rel') === 'import') {\n        // If this import (polyfilled or not) has its root node available,\n        // walk it.\n        const importNode = (element as HTMLImportElement).import;\n        if (visitedImports === undefined) {\n          visitedImports = new Set();\n        }\n        if (importNode instanceof Node && !visitedImports.has(importNode)) {\n          // Prevent multiple walks of the same import root.\n          visitedImports.add(importNode);\n\n          for (let child = importNode.firstChild; child;\n               child = child.nextSibling) {\n            walkDeepDescendantElements(child, callback, visitedImports);\n          }\n        }\n\n        // Ignore descendants of import links to prevent attempting to walk the\n        // elements created by the HTML Imports polyfill that we just walked\n        // above.\n        node = nextSiblingOrAncestorSibling(root, element);\n        continue;\n      } else if (localName === 'template') {\n        // Ignore descendants of templates. There shouldn't be any descendants\n        // because they will be moved into `.content` during construction in\n        // browsers that support template but, in case they exist and are still\n        // waiting to be moved by a polyfill, they will be ignored.\n        node = nextSiblingOrAncestorSibling(root, element);\n        continue;\n      }\n\n      // Walk shadow roots.\n      const shadowRoot = element.__CE_shadowRoot;\n      if (shadowRoot) {\n        for (let child = shadowRoot.firstChild; child;\n             child = child.nextSibling) {\n          walkDeepDescendantElements(child, callback, visitedImports);\n        }\n      }\n    }\n\n    node = nextNode(root, node);\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport './Externs.js';\nimport {CustomElementState as CEState} from './CustomElementState.js';\nimport {CustomElementDefinition, HTMLImportElement} from './Externs.js';\nimport * as Native from './Patch/Native.js';\nimport * as Utilities from './Utilities.js';\n\nconst NS_HTML = 'http://www.w3.org/1999/xhtml';\n\nexport default class CustomElementInternals {\n  private readonly _patchesNode: Array<(node: Node) => void> = [];\n  private readonly _patchesElement: Array<(elem: Element) => void> = [];\n  private _hasPatches = false;\n  public readonly shadyDomFastWalk: boolean;\n  public readonly useDocumentConstructionObserver: boolean;\n\n  constructor(options: {\n    shadyDomFastWalk: boolean,\n    noDocumentConstructionObserver: boolean\n  }) {\n    this.shadyDomFastWalk = options.shadyDomFastWalk;\n    this.useDocumentConstructionObserver =\n        options.noDocumentConstructionObserver;\n  }\n\n  forEachElement(\n      node: Node, callback: (elem: Element) => void,\n      visitedImports?: Set<Node>) {\n    const sd = window['ShadyDom'];\n    if (this.shadyDomFastWalk && sd && sd['inUse']) {\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        const element = node as Element;\n        callback(element);\n      }\n      // most easily gets to document, element, documentFragment\n      if ((node as Element).querySelectorAll!) {\n        const elements = sd['nativeMethods'].querySelectorAll.call(node, '*');\n        for (let i = 0; i < elements.length; i++) {\n          callback(elements[i]);\n        }\n      }\n    } else {\n      Utilities.walkDeepDescendantElements(node, callback, visitedImports);\n    }\n  }\n\n  addNodePatch(patch: (node: Node) => void) {\n    this._hasPatches = true;\n    this._patchesNode.push(patch);\n  }\n\n  addElementPatch(patch: (element: Element) => void) {\n    this._hasPatches = true;\n    this._patchesElement.push(patch);\n  }\n\n  patchTree(node: Node) {\n    if (!this._hasPatches) {\n      return;\n    }\n\n    this.forEachElement(node, element => this.patchElement(element));\n  }\n\n  patchNode(node: Node) {\n    if (!this._hasPatches) {\n      return;\n    }\n\n    if (node.__CE_patched) {\n      return;\n    }\n    node.__CE_patched = true;\n\n    for (let i = 0; i < this._patchesNode.length; i++) {\n      this._patchesNode[i](node);\n    }\n  }\n\n  patchElement(element: Element) {\n    if (!this._hasPatches) {\n      return;\n    }\n\n    if (element.__CE_patched) {\n      return;\n    }\n    element.__CE_patched = true;\n\n    for (let i = 0; i < this._patchesNode.length; i++) {\n      this._patchesNode[i](element);\n    }\n\n    for (let i = 0; i < this._patchesElement.length; i++) {\n      this._patchesElement[i](element);\n    }\n  }\n\n  connectTree(root: Node) {\n    const elements: Array<Element> = [];\n\n    this.forEachElement(root, element => elements.push(element));\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (element.__CE_state === CEState.custom) {\n        this.connectedCallback(element);\n      } else {\n        this.upgradeReaction(element as HTMLElement);\n      }\n    }\n  }\n\n  disconnectTree(root: Node) {\n    const elements: Array<Element> = [];\n\n    this.forEachElement(root, element => elements.push(element));\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (element.__CE_state === CEState.custom) {\n        this.disconnectedCallback(element);\n      }\n    }\n  }\n\n  /**\n   * Upgrades all uncustomized custom elements at and below a root node for\n   * which there is a definition. When custom element reaction callbacks are\n   * assumed to be called synchronously (which, by the current DOM / HTML spec\n   * definitions, they are *not*), callbacks for both elements customized\n   * synchronously by the parser and elements being upgraded occur in the same\n   * relative order.\n   *\n   * NOTE: This function, when used to simulate the construction of a tree\n   * that is already created but not customized (i.e. by the parser), does\n   * *not* prevent the element from reading the 'final' (true) state of the\n   * tree. For example, the element, during truly synchronous parsing /\n   * construction would see that it contains no children as they have not yet\n   * been inserted. However, this function does not modify the tree, the\n   * element will (incorrectly) have children. Additionally, self-modification\n   * restrictions for custom element constructors imposed by the DOM spec are\n   * *not* enforced.\n   *\n   *\n   * The following nested list shows the steps extending down from the HTML\n   * spec's parsing section that cause elements to be synchronously created\n   * and upgraded:\n   *\n   * The \"in body\" insertion mode:\n   * https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n   * - Switch on token:\n   *   .. other cases ..\n   *   -> Any other start tag\n   *      - [Insert an HTML element](below) for the token.\n   *\n   * Insert an HTML element:\n   * https://html.spec.whatwg.org/multipage/syntax.html#insert-an-html-element\n   * - Insert a foreign element for the token in the HTML namespace:\n   *   https://html.spec.whatwg.org/multipage/syntax.html#insert-a-foreign-element\n   *   - Create an element for a token:\n   *     https://html.spec.whatwg.org/multipage/syntax.html#create-an-element-for-the-token\n   *     - Will execute script flag is true?\n   *       - (Element queue pushed to the custom element reactions stack.)\n   *     - Create an element:\n   *       https://dom.spec.whatwg.org/#concept-create-element\n   *       - Sync CE flag is true?\n   *         - Constructor called.\n   *         - Self-modification restrictions enforced.\n   *       - Sync CE flag is false?\n   *         - (Upgrade reaction enqueued.)\n   *     - Attributes appended to element.\n   *       (`attributeChangedCallback` reactions enqueued.)\n   *     - Will execute script flag is true?\n   *       - (Element queue popped from the custom element reactions stack.\n   *         Reactions in the popped stack are invoked.)\n   *   - (Element queue pushed to the custom element reactions stack.)\n   *   - Insert the element:\n   *     https://dom.spec.whatwg.org/#concept-node-insert\n   *     - Shadow-including descendants are connected. During parsing\n   *       construction, there are no shadow-*excluding* descendants.\n   *       However, the constructor may have validly attached a shadow\n   *       tree to itself and added descendants to that shadow tree.\n   *       (`connectedCallback` reactions enqueued.)\n   *   - (Element queue popped from the custom element reactions stack.\n   *     Reactions in the popped stack are invoked.)\n   */\n  patchAndUpgradeTree(root: Node, options: {\n    visitedImports?: Set<Node>,\n    upgrade?: (elem: HTMLElement) => void\n  } = {}) {\n    const visitedImports = options.visitedImports;\n    const upgrade =\n        options.upgrade || (element => this.upgradeReaction(element));\n\n    const elements: Array<Element> = [];\n\n    const gatherElements = (element: Element) => {\n      if (this._hasPatches) {\n        this.patchElement(element);\n      }\n      if (element.localName === 'link' &&\n          element.getAttribute('rel') === 'import') {\n        const importElem = element as HTMLImportElement;\n        // The HTML Imports polyfill sets a descendant element of the link to\n        // the `import` property, specifically this is *not* a Document.\n        const importNode = importElem.import;\n\n        if (importNode instanceof Node) {\n          importNode.__CE_isImportDocument = true;\n          // Connected links are associated with the global registry.\n          importNode.__CE_registry = document.__CE_registry;\n        }\n\n\n\n        if (importNode &&\n            (importNode as HTMLImportDocument).readyState === 'complete') {\n          importNode.__CE_documentLoadHandled = true;\n        } else {\n          // If this link's import root is not available, its contents can't\n          // be walked. Wait for 'load' and walk it when it's ready.\n          element.addEventListener('load', () => {\n            const importNode = importElem.import!;\n\n            if (importNode.__CE_documentLoadHandled) {\n              return;\n            }\n            importNode.__CE_documentLoadHandled = true;\n\n            // Clone the `visitedImports` set that was populated sync during\n            // the `patchAndUpgradeTree` call that caused this 'load' handler\n            // to be added. Then, remove *this* link's import node so that we\n            // can walk that import again, even if it was partially walked\n            // later during the same `patchAndUpgradeTree` call.\n            const clonedVisitedImports = new Set<Node>();\n            if (visitedImports) {\n              // IE11 does not support constructing a set using an iterable.\n              visitedImports.forEach(item => clonedVisitedImports.add(item));\n              clonedVisitedImports.delete(importNode);\n            }\n            this.patchAndUpgradeTree(\n                importNode, {visitedImports: clonedVisitedImports, upgrade});\n          });\n        }\n      } else {\n        elements.push(element);\n      }\n    };\n\n    // `forEachElement` populates (and internally checks against)\n    // `visitedImports` when traversing a loaded import.\n    this.forEachElement(root, gatherElements, visitedImports);\n\n    for (let i = 0; i < elements.length; i++) {\n      upgrade(elements[i] as HTMLElement);\n    }\n  }\n\n  upgradeReaction(element: HTMLElement) {\n    try {\n      const definition = this._lookupACustomElementDefinition(\n          element.ownerDocument!, element.localName);\n      if (definition) {\n        this._upgradeAnElement(element, definition);\n      }\n    } catch (e) {\n      this.reportTheException(e);\n    }\n  }\n\n  /**\n   * @see https://html.spec.whatwg.org/multipage/custom-elements.html#concept-upgrade-an-element\n   */\n  private _upgradeAnElement(\n      element: HTMLElement, definition: CustomElementDefinition) {\n    const currentState = element.__CE_state;\n    if (currentState !== undefined) {\n      return;\n    }\n\n    definition.constructionStack.push(element);\n\n    try {\n      try {\n        const result = new (definition.constructorFunction)();\n        if (result !== element) {\n          throw new Error(\n              'The custom element constructor did not produce the element being upgraded.');\n        }\n      } finally {\n        definition.constructionStack.pop();\n      }\n    } catch (e) {\n      element.__CE_state = CEState.failed;\n      throw e;\n    }\n\n    element.__CE_state = CEState.custom;\n    element.__CE_definition = definition;\n\n    // Check `hasAttributes` here to avoid iterating when it's not necessary.\n    if (definition.attributeChangedCallback && element.hasAttributes()) {\n      const observedAttributes = definition.observedAttributes;\n      for (let i = 0; i < observedAttributes.length; i++) {\n        const name = observedAttributes[i];\n        const value = element.getAttribute(name);\n        if (value !== null) {\n          this.attributeChangedCallback(element, name, null, value, null);\n        }\n      }\n    }\n\n    if (Utilities.isConnected(element)) {\n      this.connectedCallback(element);\n    }\n  }\n\n  connectedCallback(element: Element) {\n    const definition = element.__CE_definition!;\n    if (definition.connectedCallback) {\n      try {\n        definition.connectedCallback.call(element);\n      } catch (e) {\n        this.reportTheException(e);\n      }\n    }\n  }\n\n  disconnectedCallback(element: Element) {\n    const definition = element.__CE_definition!;\n    if (definition.disconnectedCallback) {\n      try {\n        definition.disconnectedCallback.call(element);\n      } catch (e) {\n        this.reportTheException(e);\n      }\n    }\n  }\n\n  attributeChangedCallback(\n      element: Element, name: string, oldValue?: string|null,\n      newValue?: string|null, namespace?: string|null) {\n    const definition = element.__CE_definition!;\n    if (definition.attributeChangedCallback &&\n        definition.observedAttributes.indexOf(name) > -1) {\n      try {\n        definition.attributeChangedCallback.call(\n            element, name, oldValue, newValue, namespace);\n      } catch (e) {\n        this.reportTheException(e);\n      }\n    }\n  }\n\n  /**\n   * Runs HTML's 'look up a custom element definition', excluding the namespace\n   * check.\n   *\n   * @see https://html.spec.whatwg.org/multipage/custom-elements.html#look-up-a-custom-element-definition\n   */\n  private _lookupACustomElementDefinition(doc: Document, localName: string):\n      CustomElementDefinition|undefined {\n    // The document must be associated with a registry.\n    const registry = doc.__CE_registry;\n    if (!registry) {\n      return;\n    }\n\n    // Prevent elements created in documents without a browsing context from\n    // upgrading.\n    //\n    // https://html.spec.whatwg.org/multipage/custom-elements.html#look-up-a-custom-element-definition\n    //   \"If document does not have a browsing context, return null.\"\n    //\n    // https://html.spec.whatwg.org/multipage/window-object.html#dom-document-defaultview\n    //   \"The defaultView IDL attribute of the Document interface, on getting,\n    //   must return this Document's browsing context's WindowProxy object, if\n    //   this Document has an associated browsing context, or null otherwise.\"\n    if (!doc.defaultView && !doc.__CE_isImportDocument) {\n      return;\n    }\n\n    return registry.internal_localNameToDefinition(localName);\n  }\n\n  /**\n   * Runs the DOM's 'create an element'. If namespace is not null, then the\n   * native `createElementNS` is used. Otherwise, `createElement` is used.\n   *\n   * Note, the template polyfill only wraps `createElement`, preventing this\n   * function from using `createElementNS` in all cases.\n   *\n   * @see https://dom.spec.whatwg.org/#concept-create-element\n   */\n  createAnElement(doc: Document, localName: string, namespace: string|null):\n      Element {\n    const registry = doc.__CE_registry;\n    // Only create custom elements if the document is associated with a\n    // registry.\n    if (registry && (namespace === null || namespace === NS_HTML)) {\n      const definition = registry.internal_localNameToDefinition(localName);\n      if (definition) {\n        try {\n          const result = new (definition.constructorFunction)();\n\n          // These conformance checks can't be performed when the user calls\n          // the element's constructor themselves. However, this also true in\n          // native implementations.\n\n          if (result.__CE_state === undefined ||\n              result.__CE_definition === undefined) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The returned value was not constructed with the HTMLElement ' +\n                'constructor.');\n          }\n\n          if (result.namespaceURI !== NS_HTML) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element\\'s namespace must be the HTML ' +\n                'namespace.');\n          }\n\n          // The following Errors should be DOMExceptions but DOMException\n          // isn't constructible in all browsers.\n\n          if (result.hasAttributes()) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element must not have any attributes.');\n          }\n\n          // ShadyDOM doesn't wrap `#hasChildNodes`, so we check `#firstChild`\n          // instead.\n          if (result.firstChild !== null) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element must not have any children.');\n          }\n\n          if (result.parentNode !== null) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element must not have a parent node.');\n          }\n\n          if (result.ownerDocument !== doc) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element\\'s owner document is incorrect.');\n          }\n\n          if (result.localName !== localName) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element\\'s local name is incorrect.');\n          }\n\n          return result;\n        } catch (e) {\n          this.reportTheException(e);\n\n          // When construction fails, a new HTMLUnknownElement is produced.\n          // However, there's no direct way to create one, so we create a\n          // regular HTMLElement and replace its prototype.\n          const result = namespace === null ?\n              Native.Document_createElement.call(doc, localName) :\n              Native.Document_createElementNS.call(doc, namespace, localName);\n          Object.setPrototypeOf(result, HTMLUnknownElement.prototype);\n          result.__CE_state = CEState.failed;\n          result.__CE_definition = undefined;\n          this.patchElement(result);\n          return result;\n        }\n      }\n    }\n\n    const result = namespace === null ?\n        Native.Document_createElement.call(doc, localName) :\n        Native.Document_createElementNS.call(doc, namespace, localName);\n    this.patchElement(result);\n    return result;\n  }\n\n  /**\n   * Runs the DOM's 'report the exception' algorithm.\n   *\n   * @see https://html.spec.whatwg.org/multipage/webappapis.html#report-the-exception\n   */\n  reportTheException(error: Error) {\n    const message = error.message;\n    const filename =\n        /* Safari */ error.sourceURL || /* Firefox */ error.fileName || '';\n    const lineno =\n        /* Safari */ error.line || /* Firefox */ error.lineNumber || 0;\n    const colno =\n        /* Safari */ error.column || /* Firefox */ error.columnNumber || 0;\n\n    let event: ErrorEvent|undefined = undefined;\n    if (ErrorEvent.prototype.initErrorEvent === undefined) {\n      event = new ErrorEvent(\n          'error', {cancelable: true, message, filename, lineno, colno, error});\n    } else {\n      event = document.createEvent('ErrorEvent') as ErrorEvent;\n      // initErrorEvent(type, bubbles, cancelable, message, filename, line)\n      event.initErrorEvent!('error', false, true, message, filename, lineno);\n      // Hack for IE, where ErrorEvent#preventDefault does not set\n      // #defaultPrevented to true.\n      event.preventDefault = function(this: ErrorEvent) {\n        Object.defineProperty(this, 'defaultPrevented', {\n          configurable: true,\n          get: function(this: ErrorEvent) {\n            return true;\n          },\n        });\n      };\n    }\n\n    if (event.error === undefined) {\n      Object.defineProperty(event, 'error', {\n        configurable: true,\n        enumerable: true,\n        get: function() {\n          return error;\n        },\n      });\n    }\n\n    window.dispatchEvent(event);\n    if (!event.defaultPrevented) {\n      // In 'report the exception', UAs may optionally write errors to the\n      // console if their associated ErrorEvent isn't handled during dispatch\n      // (indicated by calling `preventDefault`). In practice, these errors are\n      // always displayed.\n      console.error(error);\n    }\n  }\n}\n\ndeclare interface HTMLImportDocument extends Node {\n  readyState: 'complete'|string;\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from './CustomElementInternals.js';\nimport CustomElementRegistry from './CustomElementRegistry.js';\nimport PatchDocument from './Patch/Document.js';\nimport PatchDocumentFragment from './Patch/DocumentFragment.js';\nimport PatchElement from './Patch/Element.js';\nimport PatchHTMLElement from './Patch/HTMLElement.js';\nimport PatchNode from './Patch/Node.js';\n\nconst priorCustomElements = window['customElements'];\n\nfunction installPolyfill() {\n  const noDocumentConstructionObserver =\n      !!(priorCustomElements?.['noDocumentConstructionObserver']);\n  const shadyDomFastWalk = !!(priorCustomElements?.['shadyDomFastWalk']);\n\n  const internals = new CustomElementInternals(\n      {noDocumentConstructionObserver, shadyDomFastWalk});\n\n  PatchHTMLElement(internals);\n  PatchDocument(internals);\n  PatchDocumentFragment(internals);\n  PatchNode(internals);\n  PatchElement(internals);\n\n  const customElements = new CustomElementRegistry(internals);\n\n  // The main document is associated with the global registry.\n  document.__CE_registry = customElements;\n\n  Object.defineProperty(window, 'customElements', {\n    configurable: true,\n    enumerable: true,\n    value: customElements,\n  });\n}\n\nif (!priorCustomElements || priorCustomElements['forcePolyfill'] ||\n    (typeof priorCustomElements['define'] != 'function') ||\n    (typeof priorCustomElements['get'] != 'function')) {\n  installPolyfill();\n}\n\n// This is NOT public API and is only meant to work around a GC bug in older\n// versions of Safari that randomly removes the polyfill during tests.\n(window as any)['__CE_installPolyfill'] = installPolyfill;\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nexport default class Deferred<T> {\n  private _value: T|undefined = undefined;\n\n  private _resolve!: (val: T) => void;\n\n  private readonly _promise: Promise<T>;\n  constructor() {\n    this._promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  resolve(value: T) {\n    if (this._value) {\n      throw new Error('Already resolved.');\n    }\n\n    this._value = value;\n    this._resolve(value);\n  }\n\n  toPromise() {\n    return this._promise;\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from './CustomElementInternals.js';\n\nexport default class DocumentConstructionObserver {\n  private readonly _internals: CustomElementInternals;\n  private readonly _document: Document;\n  private _observer: MutationObserver|undefined = undefined;\n  constructor(internals: CustomElementInternals, doc: Document) {\n    this._internals = internals;\n    this._document = doc;\n\n    // Simulate tree construction for all currently accessible nodes in the\n    // document.\n    this._internals.patchAndUpgradeTree(this._document);\n\n    if (this._document.readyState === 'loading') {\n      this._observer = new MutationObserver(this._handleMutations.bind(this));\n\n      // Nodes created by the parser are given to the observer *before* the next\n      // task runs. Inline scripts are run in a new task. This means that the\n      // observer will be able to handle the newly parsed nodes before the\n      // inline script is run.\n      this._observer.observe(this._document, {\n        childList: true,\n        subtree: true,\n      });\n    }\n  }\n\n  disconnect() {\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n  }\n\n  private _handleMutations(mutations: ReadonlyArray<MutationRecord>) {\n    // Once the document's `readyState` is 'interactive' or 'complete', all new\n    // nodes created within that document will be the result of script and\n    // should be handled by patching.\n    const readyState = this._document.readyState;\n    if (readyState === 'interactive' || readyState === 'complete') {\n      this.disconnect();\n    }\n\n    for (let i = 0; i < mutations.length; i++) {\n      const addedNodes = mutations[i].addedNodes;\n      for (let j = 0; j < addedNodes.length; j++) {\n        const node = addedNodes[j];\n        this._internals.patchAndUpgradeTree(node);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport {AlreadyConstructedMarkerType} from './AlreadyConstructedMarker.js';\nimport CustomElementInternals from './CustomElementInternals.js';\nimport Deferred from './Deferred.js';\nimport DocumentConstructionObserver from './DocumentConstructionObserver.js';\nimport {Constructor, CustomElementDefinition} from './Externs.js';\nimport * as Utilities from './Utilities.js';\n\ninterface ElementConstructor {\n  new(): HTMLElement;\n  observedAttributes?: Array<string>;\n}\ntype ConstructorGetter = () => ElementConstructor;\n\n\n/**\n * @unrestricted\n */\nexport default class CustomElementRegistry {\n  private readonly _localNameToConstructorGetter =\n      new Map<string, ConstructorGetter>();\n  private readonly _localNameToDefinition =\n      new Map<string, CustomElementDefinition>();\n  private readonly _constructorToDefinition =\n      new Map<Constructor<HTMLElement>, CustomElementDefinition>();\n  private _elementDefinitionIsRunning = false;\n  private readonly _internals: CustomElementInternals;\n  private readonly _whenDefinedDeferred =\n      new Map<string, Deferred<undefined>>();\n\n  /**\n   * The default flush callback triggers the document walk synchronously.\n   */\n  private _flushCallback: (fn: () => void) => void = (fn) => fn();\n  private _flushPending = false;\n\n  /**\n   * A map from `localName`s of definitions that were defined *after* the\n   * last flush to unupgraded elements matching that definition, in document\n   * order. Entries are added to this map when a definition is registered,\n   * but the list of elements is only populated during a flush after which\n   * all of the entries are removed. DO NOT edit outside of `#_flush`.\n   */\n  private readonly _unflushedLocalNames: Array<string> = [];\n\n  private readonly _documentConstructionObserver: DocumentConstructionObserver|\n      undefined;\n\n  constructor(internals: CustomElementInternals) {\n    this._internals = internals;\n    this._documentConstructionObserver =\n        internals.useDocumentConstructionObserver ?\n        new DocumentConstructionObserver(internals, document) :\n        undefined;\n  }\n\n  polyfillDefineLazy(localName: string, constructorGetter: ConstructorGetter) {\n    if (!(constructorGetter instanceof Function)) {\n      throw new TypeError(\n          'Custom element constructor getters must be functions.');\n    }\n    this.internal_assertCanDefineLocalName(localName);\n    this._localNameToConstructorGetter.set(localName, constructorGetter);\n    this._unflushedLocalNames.push(localName);\n    // If we've already called the flush callback and it hasn't called back\n    // yet, don't call it again.\n    if (!this._flushPending) {\n      this._flushPending = true;\n      this._flushCallback(() => this._flush());\n    }\n  }\n\n  define(localName: string, constructor: Function) {\n    if (!(constructor instanceof Function)) {\n      throw new TypeError('Custom element constructors must be functions.');\n    }\n\n    this.internal_assertCanDefineLocalName(localName);\n\n    this.internal_reifyDefinition(localName, constructor as ElementConstructor);\n    this._unflushedLocalNames.push(localName);\n    // If we've already called the flush callback and it hasn't called back\n    // yet, don't call it again.\n    if (!this._flushPending) {\n      this._flushPending = true;\n      this._flushCallback(() => this._flush());\n    }\n  }\n\n  internal_assertCanDefineLocalName(localName: string) {\n    if (!Utilities.isValidCustomElementName(localName)) {\n      throw new SyntaxError(`The element name '${localName}' is not valid.`);\n    }\n\n    if (this.internal_localNameToDefinition(localName)) {\n      throw new Error(\n          `A custom element with name ` +\n          `'${localName}' has already been defined.`);\n    }\n\n    if (this._elementDefinitionIsRunning) {\n      throw new Error('A custom element is already being defined.');\n    }\n  }\n\n  internal_reifyDefinition(localName: string, constructor: ElementConstructor) {\n    this._elementDefinitionIsRunning = true;\n\n    let connectedCallback: CustomElementDefinition['connectedCallback'];\n    let disconnectedCallback: CustomElementDefinition['disconnectedCallback'];\n    let adoptedCallback: CustomElementDefinition['adoptedCallback'];\n    let attributeChangedCallback:\n        CustomElementDefinition['attributeChangedCallback'];\n    let observedAttributes: CustomElementDefinition['observedAttributes'];\n    try {\n      const prototype = constructor.prototype;\n      if (!(prototype instanceof Object)) {\n        throw new TypeError(\n            'The custom element constructor\\'s prototype is not an object.');\n      }\n\n      type CEReactionCallback = 'connectedCallback'|'disconnectedCallback'|\n          'adoptedCallback'|'attributeChangedCallback';\n      const getCallback =\n          function getCallback(name: CEReactionCallback) {\n        const callbackValue = prototype[name];\n        if (callbackValue !== undefined &&\n            !(callbackValue instanceof Function)) {\n          throw new Error(`The '${name}' callback must be a function.`);\n        }\n        return callbackValue;\n      }\n\n      connectedCallback = getCallback('connectedCallback');\n      disconnectedCallback = getCallback('disconnectedCallback');\n      adoptedCallback = getCallback('adoptedCallback');\n      attributeChangedCallback = getCallback('attributeChangedCallback');\n      // `observedAttributes` should not be read unless an\n      // `attributesChangedCallback` exists\n      observedAttributes =\n          (attributeChangedCallback && constructor['observedAttributes']) || [];\n    } catch (e) {\n      throw e;\n    } finally {\n      this._elementDefinitionIsRunning = false;\n    }\n\n    const definition = {\n      localName,\n      constructorFunction: constructor,\n      connectedCallback,\n      disconnectedCallback,\n      adoptedCallback,\n      attributeChangedCallback,\n      observedAttributes,\n      constructionStack: [] as Array<HTMLElement|AlreadyConstructedMarkerType>,\n    };\n\n    this._localNameToDefinition.set(localName, definition);\n    this._constructorToDefinition.set(\n        definition.constructorFunction, definition);\n\n    return definition;\n  }\n\n  upgrade(node: Node): void {\n    this._internals.patchAndUpgradeTree(node);\n  }\n\n  private _flush() {\n    // If no new definitions were defined, don't attempt to flush. This could\n    // happen if a flush callback keeps the function it is given and calls it\n    // multiple times.\n    if (this._flushPending === false) {\n      return;\n    }\n    this._flushPending = false;\n\n    /**\n     * Unupgraded elements with definitions that were defined *before* the last\n     * flush, in document order.\n     */\n    const elementsWithStableDefinitions: Array<HTMLElement> = [];\n\n    const unflushedLocalNames = this._unflushedLocalNames;\n    const elementsWithPendingDefinitions =\n        new Map<string, Array<HTMLElement>>();\n    for (let i = 0; i < unflushedLocalNames.length; i++) {\n      elementsWithPendingDefinitions.set(unflushedLocalNames[i], []);\n    }\n\n    this._internals.patchAndUpgradeTree(document, {\n      upgrade: element => {\n        // Ignore the element if it has already upgraded or failed to upgrade.\n        if (element.__CE_state !== undefined) {\n          return;\n        }\n\n        const localName = element.localName;\n\n        // If there is an applicable pending definition for the element, add the\n        // element to the list of elements to be upgraded with that definition.\n        const pendingElements = elementsWithPendingDefinitions.get(localName);\n        if (pendingElements) {\n          pendingElements.push(element);\n          // If there is *any other* applicable definition for the element, add\n          // it to the list of elements with stable definitions that need to be\n          // upgraded.\n        } else if (this._localNameToDefinition.has(localName)) {\n          elementsWithStableDefinitions.push(element);\n        }\n      },\n    });\n\n    // Upgrade elements with 'stable' definitions first.\n    for (let i = 0; i < elementsWithStableDefinitions.length; i++) {\n      this._internals.upgradeReaction(elementsWithStableDefinitions[i]);\n    }\n\n    // Upgrade elements with 'pending' definitions in the order they were\n    // defined.\n    for (let i = 0; i < unflushedLocalNames.length; i++) {\n      const localName = unflushedLocalNames[i];\n      const pendingUpgradableElements =\n          elementsWithPendingDefinitions.get(localName)!;\n\n      // Attempt to upgrade all applicable elements.\n      for (let i = 0; i < pendingUpgradableElements.length; i++) {\n        this._internals.upgradeReaction(pendingUpgradableElements[i]);\n      }\n\n      // Resolve any promises created by `whenDefined` for the definition.\n      const deferred = this._whenDefinedDeferred.get(localName);\n      if (deferred) {\n        deferred.resolve(undefined);\n      }\n    }\n\n    unflushedLocalNames.length = 0;\n  }\n\n  get(localName: string): undefined|{new(): HTMLElement} {\n    const definition = this.internal_localNameToDefinition(localName);\n    if (definition) {\n      return definition.constructorFunction;\n    }\n\n    return undefined;\n  }\n\n  whenDefined(localName: string): Promise<void> {\n    if (!Utilities.isValidCustomElementName(localName)) {\n      return Promise.reject(new SyntaxError(\n          `'${localName}' is not a valid custom element name.`));\n    }\n\n    const prior = this._whenDefinedDeferred.get(localName);\n    if (prior) {\n      return prior.toPromise();\n    }\n\n    const deferred = new Deferred<undefined>();\n    this._whenDefinedDeferred.set(localName, deferred);\n\n    // Resolve immediately if the given local name has a regular or lazy\n    // definition *and* the full document walk to upgrade elements with that\n    // local name has already happened.\n    //\n    // The behavior of the returned promise differs between the lazy and the\n    // non-lazy cases if the definition fails. Normally, the definition would\n    // fail synchronously and no pending promises would resolve. However, if\n    // the definition is lazy but has not yet been reified, the promise is\n    // resolved early here even though it might fail later when reified.\n    const anyDefinitionExists = this._localNameToDefinition.has(localName) ||\n        this._localNameToConstructorGetter.has(localName);\n    const definitionHasFlushed =\n        this._unflushedLocalNames.indexOf(localName) === -1;\n    if (anyDefinitionExists && definitionHasFlushed) {\n      deferred.resolve(undefined);\n    }\n\n    return deferred.toPromise();\n  }\n\n  polyfillWrapFlushCallback(outer: (fn: () => void) => void) {\n    if (this._documentConstructionObserver) {\n      this._documentConstructionObserver.disconnect();\n    }\n    const inner = this._flushCallback;\n    this._flushCallback = flush => outer(() => inner(flush));\n  }\n\n  internal_localNameToDefinition(localName: string): CustomElementDefinition\n      |undefined {\n    const existingDefinition = this._localNameToDefinition.get(localName);\n    if (existingDefinition) {\n      return existingDefinition;\n    }\n\n    const constructorGetter = this._localNameToConstructorGetter.get(localName);\n    if (constructorGetter) {\n      this._localNameToConstructorGetter.delete(localName);\n      try {\n        return this.internal_reifyDefinition(localName, constructorGetter());\n      } catch (e) {\n        this._internals.reportTheException(e);\n      }\n    }\n\n    return undefined;\n  }\n\n  internal_constructorToDefinition(constructor: ElementConstructor):\n      CustomElementDefinition|undefined {\n    return this._constructorToDefinition.get(constructor);\n  }\n}\n\n// Closure compiler exports.\nwindow['CustomElementRegistry'] =\n    CustomElementRegistry as unknown as typeof window['CustomElementRegistry'];\nCustomElementRegistry.prototype['define'] =\n    CustomElementRegistry.prototype.define;\nCustomElementRegistry.prototype['upgrade'] =\n    CustomElementRegistry.prototype.upgrade;\nCustomElementRegistry.prototype['get'] = CustomElementRegistry.prototype.get;\nCustomElementRegistry.prototype['whenDefined'] =\n    CustomElementRegistry.prototype.whenDefined;\nCustomElementRegistry.prototype['polyfillDefineLazy'] =\n    CustomElementRegistry.prototype.polyfillDefineLazy;\nCustomElementRegistry.prototype['polyfillWrapFlushCallback'] =\n    CustomElementRegistry.prototype.polyfillWrapFlushCallback;\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../../CustomElementInternals.js';\nimport * as Utilities from '../../Utilities.js';\n\ntype NativeMethod = (this: Node, ...args: Array<Node|string>) => void;\n\ninterface ParentNodeNativeMethods {\n  prepend: NativeMethod;\n  append: NativeMethod;\n}\n\nexport default function(\n    internals: CustomElementInternals,\n    destination: ParentNode,\n    builtIn: ParentNodeNativeMethods) {\n  function appendPrependPatch(builtInMethod: NativeMethod): NativeMethod {\n    return function(...nodes) {\n      /**\n       * A copy of `nodes`, with any DocumentFragment replaced by its children.\n       */\n      const flattenedNodes: Array<Node|string> = [];\n\n      /**\n       * Elements in `nodes` that were connected before this call.\n       */\n      const connectedElements: Array<Node> = [];\n\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n\n        if (node instanceof Element && Utilities.isConnected(node)) {\n          connectedElements.push(node);\n        }\n\n        if (node instanceof DocumentFragment) {\n          for (let child = node.firstChild; child; child = child.nextSibling) {\n            flattenedNodes.push(child);\n          }\n        } else {\n          flattenedNodes.push(node);\n        }\n      }\n\n      builtInMethod.apply(this, nodes);\n\n      for (let i = 0; i < connectedElements.length; i++) {\n        internals.disconnectTree(connectedElements[i]);\n      }\n\n      if (Utilities.isConnected(this)) {\n        for (let i = 0; i < flattenedNodes.length; i++) {\n          const node = flattenedNodes[i];\n          if (node instanceof Element) {\n            internals.connectTree(node);\n          }\n        }\n      }\n    };\n  }\n\n  if (builtIn.prepend !== undefined) {\n    destination.prepend = appendPrependPatch(builtIn.prepend);\n  }\n\n  if (builtIn.append !== undefined) {\n    destination.append = appendPrependPatch(builtIn.append);\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../CustomElementInternals.js';\nimport CEState from '../CustomElementState.js';\nimport * as Utilities from '../Utilities.js';\n\nimport PatchChildNode from './Interface/ChildNode.js';\nimport PatchParentNode from './Interface/ParentNode.js';\nimport * as Native from './Native.js';\n\nexport default function(internals: CustomElementInternals) {\n  if (Native.Element_attachShadow) {\n    Element.prototype.attachShadow = function(\n        this: Element, init: ShadowRootInit) {\n      const shadowRoot = Native.Element_attachShadow.call(this, init);\n      internals.patchNode(shadowRoot);\n      this.__CE_shadowRoot = shadowRoot;\n      return shadowRoot;\n    };\n  }\n\n\n  function patch_innerHTML(\n      destination: Element, baseDescriptor: PropertyDescriptor) {\n    Object.defineProperty(destination, 'innerHTML', {\n      enumerable: baseDescriptor.enumerable,\n      configurable: true,\n      get: baseDescriptor.get,\n      set: function(this: Element, htmlString) {\n        const isConnected = Utilities.isConnected(this);\n\n        // NOTE: In IE11, when using the native `innerHTML` setter, all nodes\n        // that were previously descendants of the context element have all of\n        // their children removed as part of the set - the entire subtree is\n        // 'disassembled'. This work around walks the subtree *before* using the\n        // native setter.\n        let removedElements: undefined|Array<Element> = undefined;\n        if (isConnected) {\n          removedElements = [];\n          internals.forEachElement(this, element => {\n            if (element !== this) {\n              removedElements!.push(element);\n            }\n          });\n        }\n\n        baseDescriptor.set!.call(this, htmlString);\n\n        if (removedElements) {\n          for (let i = 0; i < removedElements.length; i++) {\n            const element = removedElements[i];\n            if (element.__CE_state === CEState.custom) {\n              internals.disconnectedCallback(element);\n            }\n          }\n        }\n\n        // Only create custom elements if this element's owner document is\n        // associated with the registry.\n        if (!this.ownerDocument!.__CE_registry) {\n          internals.patchTree(this);\n        } else {\n          internals.patchAndUpgradeTree(this);\n        }\n        return htmlString;\n      },\n    });\n  }\n\n  if (Native.Element_innerHTML && Native.Element_innerHTML.get) {\n    patch_innerHTML(Element.prototype, Native.Element_innerHTML);\n  } else if (Native.HTMLElement_innerHTML && Native.HTMLElement_innerHTML.get) {\n    patch_innerHTML(HTMLElement.prototype, Native.HTMLElement_innerHTML);\n  } else {\n    internals.addElementPatch(function(element) {\n      patch_innerHTML(element, {\n        enumerable: true,\n        configurable: true,\n        // Implements getting `innerHTML` by performing an unpatched `cloneNode`\n        // of the element and returning the resulting element's `innerHTML`.\n        // TODO: Is this too expensive?\n        get: function(this: Element) {\n          return (Native.Node_cloneNode.call(this, true) as Element).innerHTML;\n        },\n        // Implements setting `innerHTML` by creating an unpatched element,\n        // setting `innerHTML` of that element and replacing the target\n        // element's children with those of the unpatched element.\n        set: function(this: Element, assignedValue) {\n          // NOTE: re-route to `content` for `template` elements.\n          // We need to do this because `template.appendChild` does not\n          // route into `template.content`.\n          const isTemplate = (this.localName === 'template');\n          const content =\n              isTemplate ? ((this) as HTMLTemplateElement).content : this;\n          const rawElement = Native.Document_createElementNS.call(\n              document, this.namespaceURI, this.localName);\n          rawElement.innerHTML = assignedValue;\n\n          while (content.childNodes.length > 0) {\n            Native.Node_removeChild.call(content, content.childNodes[0]);\n          }\n          const container = isTemplate ?\n              (rawElement as HTMLTemplateElement).content :\n              rawElement;\n          while (container.childNodes.length > 0) {\n            Native.Node_appendChild.call(content, container.childNodes[0]);\n          }\n        },\n      });\n    });\n  }\n\n\n  Element.prototype.setAttribute = function(this: Element, name, newValue) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CEState.custom) {\n      return Native.Element_setAttribute.call(this, name, newValue);\n    }\n\n    const oldValue = Native.Element_getAttribute.call(this, name);\n    Native.Element_setAttribute.call(this, name, newValue);\n    newValue = Native.Element_getAttribute.call(this, name)!;\n    internals.attributeChangedCallback(this, name, oldValue, newValue, null);\n  };\n\n  Element.prototype.setAttributeNS = function(\n      this: Element, namespace, name, newValue) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CEState.custom) {\n      return Native.Element_setAttributeNS.call(\n          this, namespace, name, newValue);\n    }\n\n    const oldValue = Native.Element_getAttributeNS.call(this, namespace, name);\n    Native.Element_setAttributeNS.call(this, namespace, name, newValue);\n    newValue = Native.Element_getAttributeNS.call(this, namespace, name)!;\n    internals.attributeChangedCallback(\n        this, name, oldValue, newValue, namespace);\n  };\n\n  Element.prototype.removeAttribute = function(this: Element, name) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CEState.custom) {\n      return Native.Element_removeAttribute.call(this, name);\n    }\n\n    const oldValue = Native.Element_getAttribute.call(this, name);\n    Native.Element_removeAttribute.call(this, name);\n    if (oldValue !== null) {\n      internals.attributeChangedCallback(this, name, oldValue, null, null);\n    }\n  };\n\n  Element.prototype.removeAttributeNS = function(\n      this: Element, namespace, name) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CEState.custom) {\n      return Native.Element_removeAttributeNS.call(this, namespace, name);\n    }\n\n    const oldValue = Native.Element_getAttributeNS.call(this, namespace, name);\n    Native.Element_removeAttributeNS.call(this, namespace, name);\n    // In older browsers, `Element#getAttributeNS` may return the empty string\n    // instead of null if the attribute does not exist. For details, see;\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS#Notes\n    const newValue = Native.Element_getAttributeNS.call(this, namespace, name);\n    if (oldValue !== newValue) {\n      internals.attributeChangedCallback(\n          this, name, oldValue, newValue, namespace);\n    }\n  };\n\n\n  function patch_insertAdjacentElement(\n      destination: Element, baseMethod: Element['insertAdjacentElement']) {\n    destination.insertAdjacentElement = function(\n        this: Element, position, element) {\n      const wasConnected = Utilities.isConnected(element);\n      const insertedElement = baseMethod.call(this, position, element)!;\n\n      if (wasConnected) {\n        internals.disconnectTree(element);\n      }\n\n      if (Utilities.isConnected(insertedElement)) {\n        internals.connectTree(element);\n      }\n      return insertedElement;\n    };\n  }\n\n  if (Native.HTMLElement_insertAdjacentElement) {\n    patch_insertAdjacentElement(\n        HTMLElement.prototype, Native.HTMLElement_insertAdjacentElement);\n  } else if (Native.Element_insertAdjacentElement) {\n    patch_insertAdjacentElement(\n        Element.prototype, Native.Element_insertAdjacentElement);\n  }\n\n\n  function patch_insertAdjacentHTML(\n      destination: Element, baseMethod: Element['insertAdjacentHTML']) {\n    /**\n     * Patches and upgrades all nodes which are siblings between `start`\n     * (inclusive) and `end` (exclusive). If `end` is `null`, then all siblings\n     * following `start` will be patched and upgraded.\n     */\n    function upgradeNodesInRange(start: Node, end: Node|null) {\n      const nodes = [];\n      for (let node: Node = start; node !== end; node = node.nextSibling!) {\n        nodes.push(node);\n      }\n      for (let i = 0; i < nodes.length; i++) {\n        internals.patchAndUpgradeTree(nodes[i]);\n      }\n    }\n\n    destination.insertAdjacentHTML = function(this: Element, position, text) {\n      const strPosition = position.toLowerCase();\n\n      if (strPosition === 'beforebegin') {\n        const marker = this.previousSibling;\n        baseMethod.call(this, strPosition, text);\n        upgradeNodesInRange(marker || this.parentNode!.firstChild!, this);\n      } else if (strPosition === 'afterbegin') {\n        const marker = this.firstChild;\n        baseMethod.call(this, strPosition, text);\n        upgradeNodesInRange(this.firstChild!, marker);\n      } else if (strPosition === 'beforeend') {\n        const marker = this.lastChild;\n        baseMethod.call(this, strPosition, text);\n        upgradeNodesInRange(marker || this.firstChild!, null);\n      } else if (strPosition === 'afterend') {\n        const marker = this.nextSibling;\n        baseMethod.call(this, strPosition, text);\n        upgradeNodesInRange(this.nextSibling!, marker);\n      } else {\n        throw new SyntaxError(\n            `The value provided (${String(strPosition)}) is ` +\n            'not one of \\'beforebegin\\', \\'afterbegin\\', \\'beforeend\\', or \\'afterend\\'.');\n      }\n    };\n  }\n\n  if (Native.HTMLElement_insertAdjacentHTML) {\n    patch_insertAdjacentHTML(\n        HTMLElement.prototype, Native.HTMLElement_insertAdjacentHTML);\n  } else if (Native.Element_insertAdjacentHTML) {\n    patch_insertAdjacentHTML(\n        Element.prototype, Native.Element_insertAdjacentHTML);\n  }\n\n\n  PatchParentNode(internals, Element.prototype, {\n    prepend: Native.Element_prepend,\n    append: Native.Element_append,\n  });\n\n  PatchChildNode(internals, Element.prototype, {\n    before: Native.Element_before,\n    after: Native.Element_after,\n    replaceWith: Native.Element_replaceWith,\n    remove: Native.Element_remove,\n  });\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nexport const CustomElementState = {\n  custom: 1,\n  failed: 2,\n} as const;\nexport type CustomElementState =\n    typeof CustomElementState.custom|typeof CustomElementState.failed;\n\nexport default CustomElementState;\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../../CustomElementInternals.js';\nimport * as Utilities from '../../Utilities.js';\n\ntype NativeMethod = (this: ChildNode, ...args: Array<Node|string>) => void;\n\ninterface ChildNodeNativeMethods {\n  before: NativeMethod;\n  after: NativeMethod;\n  replaceWith: NativeMethod;\n  remove: (this: ChildNode) => void;\n}\n\nexport default function(\n    internals: CustomElementInternals,\n    destination: ChildNode,\n    builtIn: ChildNodeNativeMethods) {\n  function beforeAfterPatch(builtInMethod: NativeMethod): NativeMethod {\n    return function(this: ChildNode, ...nodes) {\n      const flattenedNodes: Array<string|Node> = [];\n      const connectedElements: Array<Node> = [];\n\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n\n        if (node instanceof Element && Utilities.isConnected(node)) {\n          connectedElements.push(node);\n        }\n\n        if (node instanceof DocumentFragment) {\n          for (let child = node.firstChild; child; child = child.nextSibling) {\n            flattenedNodes.push(child);\n          }\n        } else {\n          flattenedNodes.push(node);\n        }\n      }\n\n      builtInMethod.apply(this, nodes);\n\n      for (let i = 0; i < connectedElements.length; i++) {\n        internals.disconnectTree(connectedElements[i]);\n      }\n\n      if (Utilities.isConnected(this)) {\n        for (let i = 0; i < flattenedNodes.length; i++) {\n          const node = flattenedNodes[i];\n          if (node instanceof Element) {\n            internals.connectTree(node);\n          }\n        }\n      }\n    };\n  }\n\n  if (builtIn.before !== undefined) {\n    destination.before = beforeAfterPatch(builtIn.before);\n  }\n\n  if (builtIn.after !== undefined) {\n    destination.after = beforeAfterPatch(builtIn.after);\n  }\n\n  if (builtIn.replaceWith !== undefined) {\n    destination.replaceWith = function(\n        this: ChildNode, ...nodes: Array<Node|string>) {\n      /**\n       * A copy of `nodes`, with any DocumentFragment replaced by its children.\n       */\n      const flattenedNodes: Array<Node|string> = [];\n\n      /**\n       * Elements in `nodes` that were connected before this call.\n       */\n      const connectedElements: Array<Node> = [];\n\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n\n        if (node instanceof Element && Utilities.isConnected(node)) {\n          connectedElements.push(node);\n        }\n\n        if (node instanceof DocumentFragment) {\n          for (let child = node.firstChild; child; child = child.nextSibling) {\n            flattenedNodes.push(child);\n          }\n        } else {\n          flattenedNodes.push(node);\n        }\n      }\n\n      const wasConnected = Utilities.isConnected(this);\n\n      builtIn.replaceWith.apply(this, nodes);\n\n      for (let i = 0; i < connectedElements.length; i++) {\n        internals.disconnectTree(connectedElements[i]);\n      }\n\n      if (wasConnected) {\n        internals.disconnectTree(this);\n        for (let i = 0; i < flattenedNodes.length; i++) {\n          const node = flattenedNodes[i];\n          if (node instanceof Element) {\n            internals.connectTree(node);\n          }\n        }\n      }\n    };\n  }\n\n  if (builtIn.remove !== undefined) {\n    destination.remove = function(this: ChildNode) {\n      const wasConnected = Utilities.isConnected(this);\n\n      builtIn.remove.call(this);\n\n      if (wasConnected) {\n        internals.disconnectTree(this);\n      }\n    };\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Represents the 'already constructed marker' used in custom\n * element construction stacks.\n *\n * https://html.spec.whatwg.org/#concept-already-constructed-marker\n */\nconst alreadyConstructedMarker = {} as {_alreadyConstructedMarker: never};\n\nexport default alreadyConstructedMarker;\nexport type AlreadyConstructedMarkerType = typeof alreadyConstructedMarker;\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport AlreadyConstructedMarker from '../AlreadyConstructedMarker.js';\nimport CustomElementInternals from '../CustomElementInternals.js';\nimport CEState from '../CustomElementState.js';\nimport {Constructor} from '../Externs.js';\nimport * as Native from './Native.js';\n\nexport default function(internals: CustomElementInternals) {\n  const PatchedHTMLElement = function HTMLElement(this: HTMLElement) {\n    // This should really be `new.target` but `new.target` can't be\n    // emulated in ES5. Assuming the user keeps the default value of the\n    // constructor's prototype's `constructor` property, this is\n    // equivalent.\n    const constructor = this.constructor as Constructor<HTMLElement>;\n\n    // Always look up the definition from the global registry.\n    const registry = document.__CE_registry!;\n    const definition = registry.internal_constructorToDefinition(constructor);\n    if (!definition) {\n      throw new Error(\n          'Failed to construct a custom element: ' +\n          'The constructor was not registered with `customElements`.');\n    }\n\n    const constructionStack = definition.constructionStack;\n\n    if (constructionStack.length === 0) {\n      const element = (Native.Document_createElement.call(\n                          document, definition.localName)) as HTMLElement;\n      Object.setPrototypeOf(element, constructor.prototype as typeof element);\n      element.__CE_state = CEState.custom;\n      element.__CE_definition = definition;\n      internals.patchElement(element);\n      return element;\n    }\n\n    const lastIndex = constructionStack.length - 1;\n    const element = constructionStack[lastIndex];\n    if (element === AlreadyConstructedMarker) {\n      const localName = definition.localName;\n      throw new Error(\n          'Failed to construct \\'' + localName + '\\': ' +\n          'This element was already constructed.');\n    }\n    const toConstructElement = element as HTMLElement;\n    constructionStack[lastIndex] = AlreadyConstructedMarker;\n\n    Object.setPrototypeOf(\n        toConstructElement, constructor.prototype as typeof toConstructElement);\n    internals.patchElement(toConstructElement);\n\n    return toConstructElement;\n  };\n\n  PatchedHTMLElement.prototype = Native.HTMLElement.prototype;\n  // Safari 9 has `writable: false` on the propertyDescriptor\n  // Make it writable so that TypeScript can patch up the\n  // constructor in the ES5 compiled code.\n  Object.defineProperty(HTMLElement.prototype, 'constructor', {\n    writable: true,\n    configurable: true,\n    enumerable: false,\n    value: PatchedHTMLElement\n  });\n\n  window['HTMLElement'] = PatchedHTMLElement as unknown as typeof HTMLElement;\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../CustomElementInternals.js';\n\nimport PatchParentNode from './Interface/ParentNode.js';\nimport * as Native from './Native.js';\n\nexport default function(internals: CustomElementInternals) {\n  Document.prototype.createElement = function(\n                                         this: Document, localName: string) {\n    return internals.createAnElement(this, localName, null);\n  } as typeof Document.prototype.createElement;\n\n  Document.prototype.importNode = function<T extends Node>(\n      this: Document, node: T, deep?: boolean): T {\n    const clone = Native.Document_importNode.call(this, node, !!deep) as T;\n    // Only create custom elements if this document is associated with the\n    // registry.\n    if (!this.__CE_registry) {\n      internals.patchTree(clone);\n    } else {\n      internals.patchAndUpgradeTree(clone);\n    }\n    return clone;\n  };\n\n  Document.prototype.createElementNS =\n      function(this: Document, namespace: string|null, localName: string) {\n    return internals.createAnElement(this, localName, namespace);\n  } as typeof Document.prototype.createElementNS;\n\n  PatchParentNode(internals, Document.prototype, {\n    prepend: Native.Document_prepend,\n    append: Native.Document_append,\n  });\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../CustomElementInternals.js';\n\nimport PatchParentNode from './Interface/ParentNode.js';\nimport * as Native from './Native.js';\n\nexport default function(internals: CustomElementInternals) {\n  PatchParentNode(internals, DocumentFragment.prototype, {\n    prepend: Native.DocumentFragment_prepend,\n    append: Native.DocumentFragment_append,\n  });\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../CustomElementInternals.js';\nimport * as Utilities from '../Utilities.js';\n\nimport * as Native from './Native.js';\n\nexport default function(internals: CustomElementInternals) {\n  // `Node#nodeValue` is implemented on `Attr`.\n  // `Node#textContent` is implemented on `Attr`, `Element`.\n\n  Node.prototype.insertBefore = function<T extends Node>(\n      this: Node, node: T, refNode: Node|null) {\n    if (node instanceof DocumentFragment) {\n      const insertedNodes = Utilities.childrenFromFragment(node);\n      const nativeResult = Native.Node_insertBefore.call(this, node, refNode);\n\n      // DocumentFragments can't be connected, so `disconnectTree` will never\n      // need to be called on a DocumentFragment's children after inserting it.\n\n      if (Utilities.isConnected(this)) {\n        for (let i = 0; i < insertedNodes.length; i++) {\n          internals.connectTree(insertedNodes[i]);\n        }\n      }\n\n      return nativeResult as T;\n    }\n\n    const nodeWasConnectedElement =\n        node instanceof Element && Utilities.isConnected(node);\n    const nativeResult =\n        Native.Node_insertBefore.call(this, node, refNode) as T;\n\n    if (nodeWasConnectedElement) {\n      internals.disconnectTree(node);\n    }\n\n    if (Utilities.isConnected(this)) {\n      internals.connectTree(node);\n    }\n\n    return nativeResult;\n  };\n\n  Node.prototype.appendChild = function<T extends Node>(this: Node, node: T) {\n    if (node instanceof DocumentFragment) {\n      const insertedNodes = Utilities.childrenFromFragment(node);\n      const nativeResult = Native.Node_appendChild.call(this, node) as T;\n\n      // DocumentFragments can't be connected, so `disconnectTree` will never\n      // need to be called on a DocumentFragment's children after inserting it.\n\n      if (Utilities.isConnected(this)) {\n        for (let i = 0; i < insertedNodes.length; i++) {\n          internals.connectTree(insertedNodes[i]);\n        }\n      }\n\n      return nativeResult;\n    }\n\n    const nodeWasConnectedElement =\n        node instanceof Element && Utilities.isConnected(node);\n    const nativeResult = Native.Node_appendChild.call(this, node) as T;\n\n    if (nodeWasConnectedElement) {\n      internals.disconnectTree(node);\n    }\n\n    if (Utilities.isConnected(this)) {\n      internals.connectTree(node);\n    }\n\n    return nativeResult;\n  };\n\n  Node.prototype.cloneNode = function(this: Node, deep) {\n    const clone = Native.Node_cloneNode.call(this, !!deep);\n    // Only create custom elements if this element's owner document is\n    // associated with the registry.\n    if (!this.ownerDocument!.__CE_registry) {\n      internals.patchTree(clone);\n    } else {\n      internals.patchAndUpgradeTree(clone);\n    }\n    return clone;\n  };\n\n  Node.prototype.removeChild = function<T extends Node>(this: Node, node: T) {\n    const nodeWasConnectedElement =\n        node instanceof Element && Utilities.isConnected(node);\n    const nativeResult = Native.Node_removeChild.call(this, node) as T;\n\n    if (nodeWasConnectedElement) {\n      internals.disconnectTree(node);\n    }\n\n    return nativeResult;\n  };\n\n  Node.prototype.replaceChild = function<T extends Node>(\n      this: Node, nodeToInsert: Node, nodeToRemove: T) {\n    if (nodeToInsert instanceof DocumentFragment) {\n      const insertedNodes = Utilities.childrenFromFragment(nodeToInsert);\n      const nativeResult =\n          Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove) as T;\n\n      // DocumentFragments can't be connected, so `disconnectTree` will never\n      // need to be called on a DocumentFragment's children after inserting it.\n\n      if (Utilities.isConnected(this)) {\n        internals.disconnectTree(nodeToRemove);\n        for (let i = 0; i < insertedNodes.length; i++) {\n          internals.connectTree(insertedNodes[i]);\n        }\n      }\n\n      return nativeResult;\n    }\n\n    const nodeToInsertWasConnectedElement =\n        nodeToInsert instanceof Element && Utilities.isConnected(nodeToInsert);\n    const nativeResult =\n        Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove) as T;\n    const thisIsConnected = Utilities.isConnected(this);\n\n    if (thisIsConnected) {\n      internals.disconnectTree(nodeToRemove);\n    }\n\n    if (nodeToInsertWasConnectedElement) {\n      internals.disconnectTree(nodeToInsert);\n    }\n\n    if (thisIsConnected) {\n      internals.connectTree(nodeToInsert);\n    }\n\n    return nativeResult;\n  };\n\n\n  function patch_textContent(\n      destination: Node, baseDescriptor: PropertyDescriptor) {\n    Object.defineProperty(destination, 'textContent', {\n      enumerable: baseDescriptor.enumerable,\n      configurable: true,\n      get: baseDescriptor.get,\n      set: function(this: Node, assignedValue) {\n        // If this is a text node then there are no nodes to disconnect.\n        if (this.nodeType === Node.TEXT_NODE) {\n          baseDescriptor.set!.call(this, assignedValue);\n          return;\n        }\n\n        let removedNodes = undefined;\n        // Checking for `firstChild` is faster than reading `childNodes.length`\n        // to compare with 0.\n        if (this.firstChild) {\n          // Using `childNodes` is faster than `children`, even though we only\n          // care about elements.\n          const childNodes = this.childNodes;\n          const childNodesLength = childNodes.length;\n          if (childNodesLength > 0 && Utilities.isConnected(this)) {\n            // Copying an array by iterating is faster than using slice.\n            removedNodes = new Array(childNodesLength);\n            for (let i = 0; i < childNodesLength; i++) {\n              removedNodes[i] = childNodes[i];\n            }\n          }\n        }\n\n        baseDescriptor.set!.call(this, assignedValue);\n\n        if (removedNodes) {\n          for (let i = 0; i < removedNodes.length; i++) {\n            internals.disconnectTree(removedNodes[i]);\n          }\n        }\n      },\n    });\n  }\n\n  if (Native.Node_textContent && Native.Node_textContent.get) {\n    patch_textContent(Node.prototype, Native.Node_textContent);\n  } else {\n    internals.addNodePatch(function(element) {\n      patch_textContent(element, {\n        enumerable: true,\n        configurable: true,\n        // NOTE: This implementation of the `textContent` getter assumes that\n        // text nodes' `textContent` getter will not be patched.\n        get: function(this: Node) {\n          const parts: Array<string|null> = [];\n\n          for (let n = this.firstChild; n; n = n.nextSibling) {\n            if (n.nodeType === Node.COMMENT_NODE) {\n              continue;\n            }\n            parts.push(n.textContent);\n          }\n\n          return parts.join('');\n        },\n        set: function(this: Node, assignedValue) {\n          while (this.firstChild) {\n            Native.Node_removeChild.call(this, this.firstChild);\n          }\n          // `textContent = null | undefined | ''` does not result in\n          // a TextNode childNode\n          if (assignedValue != null && assignedValue !== '') {\n            Native.Node_appendChild.call(\n                this, document.createTextNode(assignedValue));\n          }\n        },\n      });\n    });\n  }\n}\n","export default class Highlight extends HTMLElement {\n  constructor(highlightColor) {\n    super();\n    this.style.backgroundColor = highlightColor;\n  }\n}\n\ncustomElements.define(\"highlight-snippet\", Highlight);\n","import { getRanges } from \"./range\";\n\nfunction createHighlight(color) {\n  const hlRanges = getRanges();\n  const HighlightSnippet = customElements.get(\"highlight-snippet\");\n\n  for (let r of hlRanges) {\n    r.surroundContents(new HighlightSnippet(color));\n  }\n}\n\nfunction generateColorOptions() {\n  let colors = [\"#F7A586\", \"#ECF786\", \"#9BEBAA\", \"#9BC1EB\"];\n  let colorOptions = [];\n  for (let i = 0; i < 4; i++) {\n    let optionWrapper = document.createElement(\"div\");\n    optionWrapper.classList.add(`highlight-option-wrapper`);\n\n    let option = document.createElement(\"div\");\n    option.classList.add(`highlight-option-${i}`);\n    option.classList.add(\"highlight-option\");\n    option.setAttribute(\"data-color\", colors[i]);\n    option.onclick = function(e) {\n      const color = e.target.dataset.color;\n      createHighlight(color);\n    };\n\n    optionWrapper.append(option);\n    colorOptions.push(optionWrapper);\n  }\n  return colorOptions;\n}\n\nfunction getLastParentLineHeight() {\n  let range = document.getSelection().getRangeAt(0);\n  let endParent = range.endContainer;\n  if (endParent.nodeType !== 1) endParent = endParent.parentElement;\n\n  let lineHeight = window\n    .getComputedStyle(endParent)\n    .getPropertyValue(\"line-height\");\n  let lastParentFontSize = window\n    .getComputedStyle(endParent)\n    .getPropertyValue(\"font-size\");\n  let lastParentLineHeight =\n    lineHeight === \"normal\"\n      ? parseFloat(lastParentFontSize) * 1.2 // an approximation\n      : parseFloat(lineHeight);\n\n  return lastParentLineHeight;\n}\n\nexport function showHighlightMenu(isBackwards) {\n  let highlightMenu = document.createElement(\"div\");\n  highlightMenu.classList.add(\"highlight-menu-container\");\n\n  let pointer = document.createElement(\"div\");\n  pointer.classList.add(\"highlight-menu-pointer\");\n  highlightMenu.append(pointer);\n\n  let options = document.createElement(\"div\");\n  options.classList.add(\"highlight-menu-options\");\n  let hl_colors = generateColorOptions();\n  hl_colors.forEach(c => options.append(c));\n  highlightMenu.append(options);\n\n  document.body.append(highlightMenu);\n\n  /* Create and insert temporary span element to calculate position */\n  let range = document.getSelection().getRangeAt(0);\n  let tempPositionMarker = document.createElement(\"span\");\n  tempPositionMarker.textContent = \"&#8203\"; // zero-width character\n  let rangeCopy = range.cloneRange();\n  rangeCopy.collapse(isBackwards); // if isBackwards is true, collapse(true) collapses to the start\n  rangeCopy.insertNode(tempPositionMarker);\n  let markerCoords = tempPositionMarker.getBoundingClientRect(); // this has to come after insertNode, else it always returns 0 since it's not yet visible\n  /******************************************************************/\n\n  console.log(markerCoords.left);\n  highlightMenu.style.left = `${markerCoords.left -\n    highlightMenu.offsetWidth / 2 +\n    window.pageXOffset}px`;\n\n  const BOTTOM_GAP = 10;\n  const TOP_GAP = 8;\n\n  if (isBackwards) {\n    // menu is at start\n    highlightMenu.style.top = `${markerCoords.top -\n      highlightMenu.offsetHeight -\n      BOTTOM_GAP +\n      window.pageYOffset}px`;\n    pointer.classList.add(\"pointer-bottom\");\n  } else {\n    const vertOffset = getLastParentLineHeight();\n    highlightMenu.style.top = `${markerCoords.top +\n      vertOffset +\n      TOP_GAP +\n      window.pageYOffset}px`;\n    pointer.classList.add(\"pointer-top\");\n  }\n\n  tempPositionMarker.remove(); // cleanup, then normalize() takes care of joining text nodes back\n\n  return highlightMenu;\n}\n","function isBackwards(selection) {\n  let testRange = new Range();\n  testRange.setStart(selection.anchorNode, selection.anchorOffset);\n  testRange.setEnd(selection.focusNode, selection.focusOffset);\n\n  return testRange.collapsed;\n}\n\nfunction textInSelection(node, currentRange) {\n  return !node.data.match(/^\\s+$/) && currentRange.intersectsNode(node);\n}\n\nfunction getSelectionRanges() {\n  let range = document.getSelection().getRangeAt(0);\n  let container = range.commonAncestorContainer;\n  if (container.nodeType !== 1) {\n    container = container.parentElement; // not element so we set it to its parent elem\n  }\n\n  let selectionRanges = [];\n\n  let walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, {\n    acceptNode(node) {\n      return textInSelection(node, range)\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_REJECT;\n    }\n  });\n\n  while (walker.nextNode()) {\n    let curNode = walker.currentNode;\n    let curRange = new Range();\n\n    curRange.selectNode(curNode);\n    if (curNode === range.startContainer) {\n      if (range.startContainer === range.endContainer) {\n        curRange.setStart(curNode, range.startOffset);\n        curRange.setEnd(curNode, range.endOffset);\n      } else {\n        curRange.setStart(curNode, range.startOffset);\n      }\n    } else if (curNode === range.endContainer) {\n      curRange.setEnd(curNode, range.endOffset);\n    }\n\n    selectionRanges.push(curRange);\n  }\n\n  return selectionRanges;\n}\n\nexport { getSelectionRanges as getRanges, isBackwards };\n","import { showHighlightMenu } from \"./menu\";\nimport { isBackwards } from \"./range\";\n\nlet currentMenu = null;\nlet elemToNormalize = null;\n\ndocument.onmouseup = function(e) {\n  const selection = document.getSelection();\n\n  if (!selection || selection.rangeCount == 0 || selection.isCollapsed) {\n    return;\n  }\n\n  if (!currentMenu) {\n    const range = selection.getRangeAt(0);\n    elemToNormalize = range.endContainer;\n\n    if (elemToNormalize.nodeType === 3) {\n      elemToNormalize = elemToNormalize.parentElement;\n    }\n\n    const backwards = isBackwards(selection);\n    currentMenu = showHighlightMenu(backwards); // display option to highlight\n  }\n};\n\ndocument.onmousedown = function(e) {\n  if (currentMenu && !currentMenu.contains(e.target)) {\n    // user clicked outside of highlight options menu\n    currentMenu.remove();\n\n    if (elemToNormalize) elemToNormalize.normalize(); // important that we normalize after removing currentMenu\n\n    document.getSelection().removeAllRanges(); // when we click out of menu, this ensures that mouseup doesn't create another menu (since !currentMenu condition is fulfilled)\n    currentMenu = null;\n  } else if (currentMenu && currentMenu.contains(e.target)) {\n    // user clicked inside menu\n    return false; // only works because we didn't use addEventListener\n  }\n};\n\ndocument.onclick = function(e) {\n  // when we click on button, mouseup is triggered before onclick but\n  // since currentMenu is not deleted at this point, we still don't create\n  // a new highlight mneu\n  if (e.target.classList.contains(\"highlight-option\")) {\n    if (currentMenu) currentMenu.remove();\n    if (elemToNormalize) elemToNormalize.normalize();\n    document.getSelection().removeAllRanges();\n  }\n};\n"],"sourceRoot":""}